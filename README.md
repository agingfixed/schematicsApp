# Schematics Studio

An experimental infinite-canvas diagram editor focused on building flowcharts, org charts, and lightweight schematic documents. The goal is to provide a Figma-like authoring experience optimised for nodes, connectors, and rapid iteration.

## Getting Started

```bash
npm install
npm run dev
```

If your environment blocks direct access to the public npm registry you may need to configure a mirror before installing:

```bash
npm config set registry https://registry.npmmirror.com
```

## Available Scripts

- `npm run dev` – start the Vite development server.
- `npm run build` – type-check and produce a production build.
- `npm run preview` – preview the build output locally.
- `npm run desktop:dev` – launch the Electron shell after ensuring the web build exists.
- `npm run desktop:build` – prepare the web build and create unpacked desktop artifacts.
- `npm run desktop:package` – produce installable bundles for macOS, Windows, and Linux.

> **Tip:** `npm install` now installs the Electron dependencies automatically. If you previously skipped `postinstall` scripts you can manually run `npm --prefix apps/desktop install` before packaging.

## Desktop Shell

The Electron shell lives in `apps/desktop/` and loads the `dist/` output generated by `npm run build`. The shell maps persistent storage to `~/Documents/SchematicsApp/` so downloads, imports, and automated backups have a dedicated location across operating systems.

1. Build the web app: `npm run build`
2. Start the desktop shell: `npm run desktop:start`

For live development you can run `npm run build -- --watch` in one terminal and `npm run desktop:start` in another to keep Electron pointed at the latest assets.

### Packaging Installers

Electron Builder is configured to generate native installers for the major desktop platforms. The output is written to `apps/desktop/release/`.

```bash
npm run desktop:package
```

The command will generate:

- Windows: NSIS installer (`.exe`) and a portable `.zip` archive.
- macOS: signed `.dmg` image (unsigned by default) and `.zip` archive.
- Linux: AppImage, Debian package, and compressed tarball.

Distribute the installer that matches your target operating system. Each package bundles the static `dist/` assets produced at build time, so remember to rerun `npm run build` whenever the web client changes.

## Current Capabilities

- Infinite zoomable canvas with grid background and smooth panning.
- Palette for primary flowchart node types (rectangle, rounded rectangle, ellipse, decision diamond) plus connector tool.
- Straight connectors with selectable arrowheads, inline labels, and live preview when creating a connection.
- Undo/redo with transaction batching while dragging.
- Selection-based inspector for editing node size, fill, stroke, and connector styling.
- Mini map that visualises the entire board and recentres the viewport on click.
- Inline text editing for nodes and connectors with content-aware shortcuts (double-click to edit, escape to cancel).

## Testing Layout

The default canvas now boots with a validation scene that fans connectors across every cardinal port and a couple of floating endpoints. This makes it easy to confirm connector rendering, labeling, and request handling without any manual setup. Start the dev server and you should immediately see connectors that:

- Traverse left-to-right, right-to-left, top-to-bottom, and bottom-to-top between nodes.
- Loop back between stages to exercise multiple ports on a single node.
- Terminate at floating positions so you can inspect API behaviour for unattached endpoints.
- Display start-arrow variations (filled triangles, outlined diamonds, circles, line arrows, and inward arrows) so testers can confirm both inbound and outbound arrowhead rendering.

Feel free to duplicate or delete the seeded nodes once you finish verifying connector flows.

## Roadmap

- Orthogonal routing improvements with preserved waypoints.
- Frame and container support with auto-resize.
- Export to PNG/SVG and import templates.
- Realtime collaboration via CRDT and WebSocket layers.

Contributions and feedback are welcome while the editor is still evolving.
